{-# LANGUAGE PatternSynonyms, FunctionalDependencies, OverloadedLists, FlexibleContexts, GeneralizedNewtypeDeriving, RecursiveDo, OverloadedStrings, LambdaCase, TupleSections, MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances #-}

-- | This module shows the annotators in action on some
-- insertion sort examples
module Demo where

import Data.Maybe

import Syntax
import Eval
import Programs


-- | An annotated student program that correctly implements insertion sort
sort_correct :: IO ()
sort_correct = test_sort_exercise student_sort


-- | An annotated student program that is incorrect because
-- it does not produce a permutation of the input
sort_incorrect_perm :: IO ()
sort_incorrect_perm = test_sort_exercise student_sort_wrong_perm


-- | An annotated student program that is incorrect because
-- it does not produce a non-descending list
sort_incorrect_nondesc :: IO ()
sort_incorrect_nondesc = test_sort_exercise student_sort_wrong_nondesc


-- Simple simulation of ask-elle: it tests a foldr program for the sort specification by annotating
-- it with a dependent contract and uses some input which is normally generated by quickcheck
test_sort_exercise :: LambdaPlus -> IO ()
test_sort_exercise program = evalIO $ prelude (annotated `app` input)
    where
        annotated = a_foldr_dep contract program
        input    = list [3,1,4,1,5]
        contract = cSorting' $ Just (\env -> dropLets program `app` LPVal (fromJust (lookup "xs" env)))




-- * Other tests for lambdaplus in general


-- | Tests the isPerm specification
test_isPerm = eval $ def_isPerm (apps ["isPerm", list [3,1,4,1,5], list [1,4,3,1,5]])

-- | Tests the standard insertion sort
test_sort = eval $ (def_foldr $ def_insert $ def_sort (app "sort" (list [5,4,3,2,1,3,6])))

-- | Tests the identity function
test_id = eval (app _id _id) == (Right (VClosure "x" "x" []), MSuccess)


-- | Tests the foldr function
test_foldr = def_foldr $ apps ["foldr", _plus, 0, list [1,2,3,4,5]]

-- | Tests LPMonitor with the always passing contract
test_contract_pass = LPMonitor (CRefinement "x" (LPVal (VBool True)) (const "equivalent to CTrue") Nothing) test_foldr

-- | Tests LPMonitor with the always failing contract
test_contract_fail = LPMonitor (CRefinement "x" (LPVal (VBool False)) (const "equivalent to CFalse") Nothing) test_foldr
